"use strict";(self.webpackChunkmyapp=self.webpackChunkmyapp||[]).push([[62],{90062:function(U,p,a){a.r(p),a.d(p,{default:function(){return S}});var u=a(89380),H=a(62435),h=a(86074),i=function(D){var t=D.id;function o(){var e=document.getElementById(t);e&&(0,u.Z)(e.offsetTop-120,{maxDuration:5e3,minDuration:1e3,speed:2e3})}return(0,h.jsx)("div",{className:"scroll-down-button",children:(0,h.jsx)("button",{onClick:o,children:(0,h.jsx)("img",{src:"/portfolio/scrolldown_btn.png",width:"25px",alt:"button"})})})},S=i},89380:function(U,p){var a=function(t,o,e,c){function m(n){return n instanceof e?n:new e(function(r){r(n)})}return new(e||(e=Promise))(function(n,r){function g(l){try{T(c.next(l))}catch(d){r(d)}}function v(l){try{T(c.throw(l))}catch(d){r(d)}}function T(l){l.done?n(l.value):m(l.value).then(g,v)}T((c=c.apply(t,o||[])).next())})};function u(t){let o=0,e=0,c=t;do o+=c.offsetTop||0,e+=c.offsetLeft||0,c=c.offsetParent;while(c);return{top:o,left:e}}class H{constructor(o){this.element=o}getHorizontalScroll(){return this.element.scrollLeft}getVerticalScroll(){return this.element.scrollTop}getMaxHorizontalScroll(){return this.element.scrollWidth-this.element.clientWidth}getMaxVerticalScroll(){return this.element.scrollHeight-this.element.clientHeight}getHorizontalElementScrollOffset(o,e){return u(o).left-u(e).left}getVerticalElementScrollOffset(o,e){return u(o).top-u(e).top}scrollTo(o,e){this.element.scrollLeft=o,this.element.scrollTop=e}}class h{constructor(){this.element=window}getHorizontalScroll(){return window.scrollX||document.documentElement.scrollLeft}getVerticalScroll(){return window.scrollY||document.documentElement.scrollTop}getMaxHorizontalScroll(){return Math.max(document.body.scrollWidth,document.documentElement.scrollWidth,document.body.offsetWidth,document.documentElement.offsetWidth,document.body.clientWidth,document.documentElement.clientWidth)-window.innerWidth}getMaxVerticalScroll(){return Math.max(document.body.scrollHeight,document.documentElement.scrollHeight,document.body.offsetHeight,document.documentElement.offsetHeight,document.body.clientHeight,document.documentElement.clientHeight)-window.innerHeight}getHorizontalElementScrollOffset(o){return(window.scrollX||document.documentElement.scrollLeft)+o.getBoundingClientRect().left}getVerticalElementScrollOffset(o){return(window.scrollY||document.documentElement.scrollTop)+o.getBoundingClientRect().top}scrollTo(o,e){window.scrollTo(o,e)}}const i={elements:[],cancelMethods:[],add:(t,o)=>{i.elements.push(t),i.cancelMethods.push(o)},remove:(t,o)=>{const e=i.elements.indexOf(t);e>-1&&(o&&i.cancelMethods[e](),i.elements.splice(e,1),i.cancelMethods.splice(e,1))}},S=typeof window!="undefined",M={cancelOnUserAction:!0,easing:t=>--t*t*t+1,elementToScroll:S?window:null,horizontalOffset:0,maxDuration:3e3,minDuration:250,speed:500,verticalOffset:0};function D(t,o={}){return a(this,void 0,void 0,function*(){if(S){if(!window.Promise)throw"Browser doesn't support Promises, and animated-scroll-to depends on it, please provide a polyfill."}else return new Promise(w=>{w(!1)});let e,c,m,n=Object.assign(Object.assign({},M),o);const r=n.elementToScroll===window,g=!!n.elementToScroll.nodeName;if(!r&&!g)throw"Element to scroll needs to be either window or DOM element.";const v=r?document.documentElement:n.elementToScroll;getComputedStyle(v).getPropertyValue("scroll-behavior")==="smooth"&&console.warn(`${v.tagName} has "scroll-behavior: smooth" which can mess up with animated-scroll-to's animations`);const l=r?new h:new H(n.elementToScroll);if(t instanceof Element){if(m=t,g&&(!n.elementToScroll.contains(m)||n.elementToScroll.isSameNode(m)))throw"options.elementToScroll has to be a parent of scrollToElement";e=l.getHorizontalElementScrollOffset(m,n.elementToScroll),c=l.getVerticalElementScrollOffset(m,n.elementToScroll)}else if(typeof t=="number")e=l.getHorizontalScroll(),c=t;else if(Array.isArray(t)&&t.length===2)e=t[0]===null?l.getHorizontalScroll():t[0],c=t[1]===null?l.getVerticalScroll():t[1];else throw`Wrong function signature. Check documentation.
Available method signatures are:
  animateScrollTo(y:number, options)
  animateScrollTo([x:number | null, y:number | null], options)
  animateScrollTo(scrollToElement:Element, options)`;e+=n.horizontalOffset,c+=n.verticalOffset;const d=l.getMaxHorizontalScroll(),z=l.getHorizontalScroll();e>d&&(e=d);const E=e-z,b=l.getMaxVerticalScroll(),W=l.getVerticalScroll();c>b&&(c=b);const y=c-W,V=Math.abs(Math.round(E/1e3*n.speed)),A=Math.abs(Math.round(y/1e3*n.speed));let f=V>A?V:A;return f<n.minDuration?f=n.minDuration:f>n.maxDuration&&(f=n.maxDuration),new Promise((w,Y)=>{E===0&&y===0&&w(!0),i.remove(l.element,!0);let x;const B=()=>{k(),cancelAnimationFrame(x),w(!1)};i.add(l.element,B);const X=s=>s.preventDefault(),L=n.cancelOnUserAction?B:X,j=n.cancelOnUserAction?{passive:!0}:{passive:!1},P=["wheel","touchstart","keydown","mousedown"],k=()=>{P.forEach(s=>{l.element.removeEventListener(s,L,j)})};P.forEach(s=>{l.element.addEventListener(s,L,j)});const R=Date.now(),N=()=>{var s=Date.now()-R,F=s/f;const I=Math.round(z+E*n.easing(F)),O=Math.round(W+y*n.easing(F));s<f&&(I!==e||O!==c)?(l.scrollTo(I,O),x=requestAnimationFrame(N)):(l.scrollTo(e,c),cancelAnimationFrame(x),k(),i.remove(l.element,!1),w(!0))};x=requestAnimationFrame(N)})})}p.Z=D}}]);
